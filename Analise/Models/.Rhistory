Cargo == 9211~ "Trabalhadores elementares da agricultura",
Cargo == 9212~ "Trabalhadores elementares da pecuária",
Cargo == 9213~ "Trabalhadores elementares da agropecuária",
Cargo == 9214~ "Trabalhadores elementares da jardinagem e horticultura",
Cargo == 9215~ "Trabalhadores florestais elementares",
Cargo == 9216~ "Trabalhadores elementares da pesca e aquicultura",
Cargo == 9311~ "Trabalhadores elementares de minas e pedreiras",
Cargo == 9312~ "Trabalhadores elementares de obras públicas e da manutenção de estradas, represas e similares",
Cargo == 9313~ "Trabalhadores elementares da construção de edifícios",
Cargo == 9321~ "empacotadores manuais",
Cargo == 9329~ "Trabalhadores elementares da indústria de transformação não classificados anteriormente",
Cargo == 9331~ "Condutores de veículos acionados a pedal ou a braços",
Cargo == 9332~ "Condutores de veículos e máquinas de tração animal",
Cargo == 9333~ "Carregadores",
Cargo == 9334~ "Repositores de prateleiras",
Cargo == 9411~ "Preparadores de comidas rápidas",
Cargo == 9412~ "Ajudantes de cozinha",
Cargo == 9510~ "Trabalhadores ambulantes dos serviços e afins",
Cargo == 9520~ "Vendedores ambulantes (exclusive de serviços de alimentação)",
Cargo == 9611~ "Coletores de lixo e material reciclável",
Cargo == 9612~ "Classificadores de resíduos",
Cargo == 9613~ "Varredores e afins",
Cargo == 9621~ "Mensageiros, carregadores de bagagens e entregadores de encomendas",
Cargo == 9622~ "Pessoas que realizam várias tarefas",
Cargo == 9623~ "Coletores de dinheiro em máquinas automáticas de venda e leitores de medidores",
Cargo == 9624~ "Carregadores de água e coletores de lenha",
Cargo == 9629~ "Outras ocupações elementares não classificadas anteriormente",
Cargo == 0110~ "Oficiais das forças armadas",
Cargo == 0210~ "Graduados e praças das forças armadas",
Cargo == 0411~ "Oficiais de polícia militar",
Cargo == 0412~ "Graduados e praças da polícia militar",
Cargo == 0511~ "Oficiais de bombeiro militar",
Cargo == 0512~ "Graduados e praças do corpo de bombeiros",))
#filtrando só as de TI ( CNAE 6200 E 6300)
pnad_TI <-pnad %>%
filter(str_detect(Atividade, "Atividades dos Serviços de TI|Atividades de Prestação de Serviços de TI"))
#Criando um binding para poder apresentar o total no Excel?
pnad_TI2<-pnad_TI%>% mutate(Atividade = case_when(
Atividade=="Atividades dos Serviços de TI"~"Setor TI",
Atividade=="Atividades de Prestação de Serviços de TI"~"Setor TI",
)
)
pnad_Ativ<-rbind(pnad_TI,pnad_TI2)
##Criando as tabelas din?micas
wb <- createWorkbook(creator = Sys.getenv("Gabriel"))
#Cargo_Funcao
cf<- PivotTable$new()
cf$addData(pnad_Ativ)
cf$addColumnDataGroups("Atividade",
dataSortOrder="custom",
customSortOrder=c("Atividades dos Serviços de TI","Atividades de Prestação de Serviços de TI","Demais Setores")
)
cf$addColumnDataGroups("Regiao",
dataSortOrder="custom",
customSortOrder=c("Norte","Nordeste","Sudeste","Sul","Centro-Oeste")
)
cf$addRowDataGroups("Cargo")
cf$defineCalculation(calculationName="Total", summariseExpression="sum(Peso, na.rm=TRUE)")
cf$evaluatePivot()
addWorksheet(wb, "cargo_func")
cf$writeToExcelWorksheet(wb=wb, wsName="cargo_func",
topRowNumber=1, leftMostColumnNumber=1, applyStyles=FALSE, exportOptions=list(skipNA=TRUE, skipNaN=TRUE))
saveWorkbook(wb, file=sprintf("PNAD_%s_%s_2.xlsx",year,quarter), overwrite = TRUE)
#Renda_Cargo
rc<- PivotTable$new()
rc$addData(pnad_Ativ)
rc$addColumnDataGroups("Atividade",
dataSortOrder="custom",
customSortOrder=c("Atividades dos Serviços de TI","Atividades de Prestação de Serviços de TI","Demais Setores")
)
rc$addColumnDataGroups("Regiao",
dataSortOrder="custom",
customSortOrder=c("Norte","Nordeste","Sudeste","Sul","Centro-Oeste")
)
rc$addRowDataGroups("Cargo")
rc$defineCalculation(calculationName="Total", summariseExpression="weighted.mean(Rendimento,Peso, na.rm=TRUE)")
rc$evaluatePivot()
addWorksheet(wb, "rend_cargo")
rc$writeToExcelWorksheet(wb=wb, wsName="rend_cargo",
topRowNumber=1, leftMostColumnNumber=1, applyStyles=FALSE, exportOptions=list(skipNA=TRUE, skipNaN=TRUE))
saveWorkbook(wb, file=sprintf("PNAD_%s_%s_2.xlsx",year,quarter), overwrite = TRUE)
sprintf("concluído ano %s trimestre %s", year, quarter)
rm(list=ls(all=TRUE))
gc()
}
generate_pnad_sheet(2021,4)
generate_pnad_sheet(2021,4)
library("dplyr")
library("MatchIt")
library("lmtest")
library("sandwich")
library("arrow")
library(data.table)
options(scipen = 100, digits=4)
## Adicionando diretório ao path
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Funcoes
match_year <- function(dataframe, year, states, formula, pre_split, filter){
# Selecionando apenas o ano da iteracao para fatorar a computação necessária
df <- filter(dataframe, NU_ANO == year)
if (filter == TRUE){
# Selecionando observações de estados de interesse
df <- filter(df, SG_UF_ESC %in% states)
df <- transform(df, treated = as.numeric(treated))
}
# Separando previamente em grupo de controle e tratamento (para estrato à nível individual)
if (pre_split == TRUE){
treated <- subset(df, treated == 1 & Q025 == 1)
control <- subset(df, treated == 0 & Q025 == 0)
experiment <- rbind(treated, control)
} else {
experiment <- df
}
# Executando o matching com Coarsened Exact Matching
matching <- matchit( formula, data = experiment, method = "cem", estimand = "ATE" )
summ <- summary(matching, un = FALSE)
matched_df <- match.data(matching) %>% arrange(subclass, Q025)
# Retornando dataframe com match
retorna <- list("match" = matched_df, "summary" = summ )
return (retorna)
}
do_regression <- function(dataframe, formula){
# Performando análise de regressão
model <- lm(formula, data = dataframe, weights = weights)
#coeft <- coeftest(model, vcov. = vcovCL, cluster = ~subclass)
#coefc <- coefci(model, vcov. = vcovCL, cluster = ~subclass)
summ <- summary(model)
retorna <- list("summary" = summ)
return(retorna)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df <- transform(df, Q025 = as.numeric(Q025))
df <- transform(df, NU_ANO = as.integer(NU_ANO))
states = c("MA", "PI", "RN", "AL", "SE", "PA", "CE", "AM", "TO")
# Definindo covariaveis para o matching
#formula_match = treated ~  indice_gini + idhm_e + idhm_r + expectativa_anos_estudo + NT_MEDIA + taxa_analfabetismo_15_a_17
formula_match = Q025 ~ TP_FAIXA_ETARIA + Q001 + Q002 + Q005 + Q006 + Q022 + Q024 + Q025 + IND_CASA + NAO_BRANCO + MULHER + SOLTEIRO + ESCOLA_PUBLICA
#formula_reg = NT_MEDIA ~ treated
formula_reg = LOG_NT_MEDIA ~ Q025
print(cat("Quantidade de linhas no dataframe inicial", nrow(df)))
for (ano in 2020:2021){
print(sprintf("Executando para %s", ano))
matched_obj <- match_year(df, ano, states, formula_match, FALSE, FALSE)
print("Matching executado. Salvando dataframe.")
file <- sprintf("../../Resultados/Agg/ENEM/aux/postMatching/individuo-Q025-%s.parquet", ano)
write_parquet( matched_obj$match, file )
output <- do_regression( matched_obj$match, formula_reg )
print(matched_obj$summary)
print(output$summary)
}
library("dplyr")
library("MatchIt")
library("lmtest")
library("sandwich")
library("arrow")
library(data.table)
options(scipen = 100, digits=4)
## Adicionando diretório ao path
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Funcoes
match_year <- function(dataframe, year, states, formula, pre_split, filter){
# Selecionando apenas o ano da iteracao para fatorar a computação necessária
df <- filter(dataframe, NU_ANO == year)
if (filter == TRUE){
# Selecionando observações de estados de interesse
df <- filter(df, SG_UF_ESC %in% states)
df <- transform(df, treated = as.numeric(treated))
}
# Separando previamente em grupo de controle e tratamento (para estrato à nível individual)
if (pre_split == TRUE){
treated <- subset(df, treated == 1 & Q025 == 1)
control <- subset(df, treated == 0 & Q025 == 0)
experiment <- rbind(treated, control)
} else {
experiment <- df
}
# Executando o matching com Coarsened Exact Matching
matching <- matchit( formula, data = experiment, method = "cem", estimand = "ATE" )
summ <- summary(matching, un = FALSE)
matched_df <- match.data(matching) %>% arrange(subclass, Q025)
# Retornando dataframe com match
retorna <- list("match" = matched_df, "summary" = summ )
return (retorna)
}
do_regression <- function(dataframe, formula){
# Performando análise de regressão
model <- lm(formula, data = dataframe, weights = weights)
#coeft <- coeftest(model, vcov. = vcovCL, cluster = ~subclass)
#coefc <- coefci(model, vcov. = vcovCL, cluster = ~subclass)
summ <- summary(model)
retorna <- list("summary" = summ)
return(retorna)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df <- transform(df, Q025 = as.numeric(Q025))
df <- transform(df, NU_ANO = as.integer(NU_ANO))
states = c("MA", "PI", "RN", "AL", "SE", "PA", "CE", "AM", "TO")
# Definindo covariaveis para o matching
#formula_match = treated ~  indice_gini + idhm_e + idhm_r + expectativa_anos_estudo + NT_MEDIA + taxa_analfabetismo_15_a_17
formula_match = Q025 ~ TP_FAIXA_ETARIA + Q001 + Q002 + Q005 + Q006 + Q022 + Q024 + IND_CASA + NAO_BRANCO + MULHER + SOLTEIRO + ESCOLA_PUBLICA
#formula_reg = NT_MEDIA ~ treated
formula_reg = LOG_NT_MEDIA ~ Q025
print(cat("Quantidade de linhas no dataframe inicial", nrow(df)))
for (ano in 2020:2021){
print(sprintf("Executando para %s", ano))
matched_obj <- match_year(df, ano, states, formula_match, FALSE, FALSE)
print("Matching executado. Salvando dataframe.")
file <- sprintf("../../Resultados/Agg/ENEM/aux/postMatching/individuo-Q025-%s.parquet", ano)
write_parquet( matched_obj$match, file )
output <- do_regression( matched_obj$match, formula_reg )
print(matched_obj$summary)
print(output$summary)
}
library("dplyr")
library("MatchIt")
library("lmtest")
library("sandwich")
library("arrow")
library(data.table)
options(scipen = 100, digits=4)
## Adicionando diretório ao path
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Funcoes
match_year <- function(dataframe, year, states, formula, pre_split, filter){
# Selecionando apenas o ano da iteracao para fatorar a computação necessária
df <- filter(dataframe, NU_ANO == year)
if (filter == TRUE){
# Selecionando observações de estados de interesse
df <- filter(df, SG_UF_ESC %in% states)
df <- transform(df, treated = as.numeric(treated))
}
# Separando previamente em grupo de controle e tratamento (para estrato à nível individual)
if (pre_split == TRUE){
treated <- subset(df, treated == 1 & Q025 == 1)
control <- subset(df, treated == 0 & Q025 == 0)
experiment <- rbind(treated, control)
} else {
experiment <- df
}
# Executando o matching com Coarsened Exact Matching
matching <- matchit( formula, data = experiment, method = "cem", estimand = "ATE" )
summ <- summary(matching, un = FALSE)
matched_df <- match.data(matching) %>% arrange(subclass, Q025)
# Retornando dataframe com match
retorna <- list("match" = matched_df, "summary" = summ )
return (retorna)
}
do_regression <- function(dataframe, formula){
# Performando análise de regressão
model <- lm(formula, data = dataframe, weights = weights)
#coeft <- coeftest(model, vcov. = vcovCL, cluster = ~subclass)
#coefc <- coefci(model, vcov. = vcovCL, cluster = ~subclass)
summ <- summary(model)
retorna <- list("summary" = summ)
return(retorna)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df <- transform(df, Q025 = as.numeric(Q025))
df <- transform(df, NU_ANO = as.integer(NU_ANO))
states = c("MA", "PI", "RN", "AL", "SE", "PA", "CE", "AM", "TO")
# Definindo covariaveis para o matching
#formula_match = treated ~  indice_gini + idhm_e + idhm_r + expectativa_anos_estudo + NT_MEDIA + taxa_analfabetismo_15_a_17
formula_match = Q025 ~ TP_FAIXA_ETARIA + Q001 + Q002 + Q005 + Q006 + IND_CASA + NAO_BRANCO + MULHER + SOLTEIRO + ESCOLA_PUBLICA
#formula_reg = NT_MEDIA ~ treated
formula_reg = LOG_NT_MEDIA ~ Q025
print(cat("Quantidade de linhas no dataframe inicial", nrow(df)))
for (ano in 2020:2021){
print(sprintf("Executando para %s", ano))
matched_obj <- match_year(df, ano, states, formula_match, FALSE, FALSE)
print("Matching executado. Salvando dataframe.")
file <- sprintf("../../Resultados/Agg/ENEM/aux/postMatching/individuo-Q025-%s.parquet", ano)
write_parquet( matched_obj$match, file )
output <- do_regression( matched_obj$match, formula_reg )
print(matched_obj$summary)
print(output$summary)
}
library("dplyr")
library("MatchIt")
library("lmtest")
library("sandwich")
library("arrow")
library(data.table)
options(scipen = 100, digits=4)
## Adicionando diretório ao path
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Funcoes
match_year <- function(dataframe, year, states, formula, pre_split, filter){
# Selecionando apenas o ano da iteracao para fatorar a computação necessária
df <- filter(dataframe, NU_ANO == year)
if (filter == TRUE){
# Selecionando observações de estados de interesse
df <- filter(df, SG_UF_ESC %in% states)
df <- transform(df, treated = as.numeric(treated))
}
# Separando previamente em grupo de controle e tratamento (para estrato à nível individual)
if (pre_split == TRUE){
treated <- subset(df, treated == 1 & Q025 == 1)
control <- subset(df, treated == 0 & Q025 == 0)
experiment <- rbind(treated, control)
} else {
experiment <- df
}
# Executando o matching com Coarsened Exact Matching
matching <- matchit( formula, data = experiment, method = "cem", estimand = "ATE" )
summ <- summary(matching, un = FALSE)
matched_df <- match.data(matching) %>% arrange(subclass, Q025)
# Retornando dataframe com match
retorna <- list("match" = matched_df, "summary" = summ )
return (retorna)
}
do_regression <- function(dataframe, formula){
# Performando análise de regressão
model <- lm(formula, data = dataframe, weights = weights)
#coeft <- coeftest(model, vcov. = vcovCL, cluster = ~subclass)
#coefc <- coefci(model, vcov. = vcovCL, cluster = ~subclass)
summ <- summary(model)
retorna <- list("summary" = summ)
return(retorna)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df  %>%  transform(df, Q025 = as.numeric(Q025)) %>% transform(df, NU_ANO = as.integer(NU_ANO)) %>% filter(df, ESCOLA_PUBLICA == 1 )
states = c("MA", "PI", "RN", "AL", "SE", "PA", "CE", "AM", "TO")
# Definindo covariaveis para o matching
#formula_match = treated ~  indice_gini + idhm_e + idhm_r + expectativa_anos_estudo + NT_MEDIA + taxa_analfabetismo_15_a_17
formula_match = Q025 ~ TP_FAIXA_ETARIA + Q001 + Q002 + Q005 + Q006 + IND_CASA + NAO_BRANCO + MULHER + SOLTEIRO
#formula_reg = NT_MEDIA ~ treated
formula_reg = LOG_NT_MEDIA ~ Q025
print(cat("Quantidade de linhas no dataframe inicial", nrow(df)))
for (ano in 2020:2021){
print(sprintf("Executando para %s", ano))
matched_obj <- match_year(df, ano, states, formula_match, FALSE, FALSE)
print("Matching executado. Salvando dataframe.")
file <- sprintf("../../Resultados/Agg/ENEM/aux/postMatching/individuo-Q025-publica%s.parquet", ano)
write_parquet( matched_obj$match, file )
output <- do_regression( matched_obj$match, formula_reg )
print(matched_obj$summary)
print(output$summary)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df  %>%  transform(df, Q025 = as.numeric(Q025)) %>% transform(df, NU_ANO = as.integer(NU_ANO)) %>% filter(df, ESCOLA_PUBLICA == 1 )
df  %>%
transform(Q025 = as.numeric(Q025)) %>%
transform( NU_ANO = as.integer(NU_ANO)) %>%
filter(df, ESCOLA_PUBLICA == 1 )
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df  %>%
transform(Q025 = as.numeric(Q025)) %>%
transform( NU_ANO = as.integer(NU_ANO)) %>%
filter(ESCOLA_PUBLICA == 1 )
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df = df  %>%
transform(Q025 = as.numeric(Q025)) %>%
transform( NU_ANO = as.integer(NU_ANO)) %>%
filter(ESCOLA_PUBLICA == 1 )
library("dplyr")
library("MatchIt")
library("lmtest")
library("sandwich")
library("arrow")
library(data.table)
options(scipen = 100, digits=4)
## Adicionando diretório ao path
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Funcoes
match_year <- function(dataframe, year, states, formula, pre_split, filter){
# Selecionando apenas o ano da iteracao para fatorar a computação necessária
df <- filter(dataframe, NU_ANO == year)
if (filter == TRUE){
# Selecionando observações de estados de interesse
df <- filter(df, SG_UF_ESC %in% states)
df <- transform(df, treated = as.numeric(treated))
}
# Separando previamente em grupo de controle e tratamento (para estrato à nível individual)
if (pre_split == TRUE){
treated <- subset(df, treated == 1 & Q025 == 1)
control <- subset(df, treated == 0 & Q025 == 0)
experiment <- rbind(treated, control)
} else {
experiment <- df
}
# Executando o matching com Coarsened Exact Matching
matching <- matchit( formula, data = experiment, method = "cem", estimand = "ATE" )
summ <- summary(matching, un = FALSE)
matched_df <- match.data(matching) %>% arrange(subclass, Q025)
# Retornando dataframe com match
retorna <- list("match" = matched_df, "summary" = summ )
return (retorna)
}
do_regression <- function(dataframe, formula){
# Performando análise de regressão
model <- lm(formula, data = dataframe, weights = weights)
#coeft <- coeftest(model, vcov. = vcovCL, cluster = ~subclass)
#coefc <- coefci(model, vcov. = vcovCL, cluster = ~subclass)
summ <- summary(model)
retorna <- list("summary" = summ)
return(retorna)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df = df  %>%
transform(Q025 = as.numeric(Q025)) %>%
transform( NU_ANO = as.integer(NU_ANO)) %>%
filter(ESCOLA_PUBLICA == 1 )
states = c("MA", "PI", "RN", "AL", "SE", "PA", "CE", "AM", "TO")
# Definindo covariaveis para o matching
#formula_match = treated ~  indice_gini + idhm_e + idhm_r + expectativa_anos_estudo + NT_MEDIA + taxa_analfabetismo_15_a_17
formula_match = Q025 ~ TP_FAIXA_ETARIA + Q001 + Q002 + Q005 + Q006 + IND_CASA + NAO_BRANCO + MULHER + SOLTEIRO
#formula_reg = NT_MEDIA ~ treated
formula_reg = LOG_NT_MEDIA ~ Q025
print(cat("Quantidade de linhas no dataframe inicial", nrow(df)))
for (ano in 2020:2021){
print(sprintf("Executando para %s", ano))
matched_obj <- match_year(df, ano, states, formula_match, FALSE, FALSE)
print("Matching executado. Salvando dataframe.")
file <- sprintf("../../Resultados/Agg/ENEM/aux/postMatching/individuo-Q025-publica%s.parquet", ano)
write_parquet( matched_obj$match, file )
output <- do_regression( matched_obj$match, formula_reg )
print(matched_obj$summary)
print(output$summary)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df = df  %>%
transform(Q025 = as.numeric(Q025)) %>%
transform( NU_ANO = as.integer(NU_ANO)) %>%
#filter(ESCOLA_PUBLICA == 1 )
mutate(COMPUTADOR = if_else(Q024 == 0, 0, 1))
View(df)
library("dplyr")
library("MatchIt")
library("lmtest")
library("sandwich")
library("arrow")
library(data.table)
options(scipen = 100, digits=4)
## Adicionando diretório ao path
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Funcoes
match_year <- function(dataframe, year, states, formula, pre_split, filter){
# Selecionando apenas o ano da iteracao para fatorar a computação necessária
df <- filter(dataframe, NU_ANO == year)
if (filter == TRUE){
# Selecionando observações de estados de interesse
df <- filter(df, SG_UF_ESC %in% states)
df <- transform(df, treated = as.numeric(treated))
}
# Separando previamente em grupo de controle e tratamento (para estrato à nível individual)
if (pre_split == TRUE){
treated <- subset(df, treated == 1 & Q025 == 1)
control <- subset(df, treated == 0 & Q025 == 0)
experiment <- rbind(treated, control)
} else {
experiment <- df
}
# Executando o matching com Coarsened Exact Matching
matching <- matchit( formula, data = experiment, method = "cem", estimand = "ATE" )
summ <- summary(matching, un = FALSE)
matched_df <- match.data(matching) %>% arrange(subclass, Q025)
# Retornando dataframe com match
retorna <- list("match" = matched_df, "summary" = summ )
return (retorna)
}
do_regression <- function(dataframe, formula){
# Performando análise de regressão
model <- lm(formula, data = dataframe, weights = weights)
#coeft <- coeftest(model, vcov. = vcovCL, cluster = ~subclass)
#coefc <- coefci(model, vcov. = vcovCL, cluster = ~subclass)
summ <- summary(model)
retorna <- list("summary" = summ)
return(retorna)
}
# Script
#df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching-municipal.parquet")
df <- read_parquet("../../Resultados/Agg/ENEM/aux/dados_para_matching_individual-20-21.parquet")
df = df  %>%
transform(Q025 = as.numeric(Q025)) %>%
transform( NU_ANO = as.integer(NU_ANO)) %>%
#filter(ESCOLA_PUBLICA == 1 )
mutate(COMPUTADOR = if_else(Q024 == 0, 0, 1))
states = c("MA", "PI", "RN", "AL", "SE", "PA", "CE", "AM", "TO")
# Definindo covariaveis para o matching
#formula_match = treated ~  indice_gini + idhm_e + idhm_r + expectativa_anos_estudo + NT_MEDIA + taxa_analfabetismo_15_a_17
formula_match = COMPUTADOR ~ TP_FAIXA_ETARIA + Q001 + Q002 + Q005 + Q006 + IND_CASA + NAO_BRANCO + MULHER + SOLTEIRO
#formula_reg = NT_MEDIA ~ treated
formula_reg = LOG_NT_MEDIA ~ COMPUTADOR
print(cat("Quantidade de linhas no dataframe inicial", nrow(df)))
for (ano in 2020:2021){
print(sprintf("Executando para %s", ano))
matched_obj <- match_year(df, ano, states, formula_match, FALSE, FALSE)
print("Matching executado. Salvando dataframe.")
file <- sprintf("../../Resultados/Agg/ENEM/aux/postMatching/individuo-Q024-%s.parquet", ano)
write_parquet( matched_obj$match, file )
#output <- do_regression( matched_obj$match, formula_reg )
#print(matched_obj$summary)
#print(output$summary)
}
